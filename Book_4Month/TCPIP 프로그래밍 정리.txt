<TCP/IP 프로그래밍 정리>

0. 용어 정리
바인드 : 접점정보 연결
펜딩 : 보류중

1. TCP/IP 모델
응용 : FTP, HTTP, DNS(주소) : 메시지 작성 및 전송
전송 : TCP(세그먼트), UDP(데이터그램) : 전송 확인과 오류 해결을 하는 단계
네트워크 : 라우터, IPV4(주소, 게임은 주로 IPV4를 사용, 종종 IPV6를 사용하기도 함) : 네트워크 간 경로 설정 
데이터링크 : 스위치, 이더넷, MAC(주소) : 네트워크 내 경로 설정(사설/개인 IP주소 연결)
물리 : 광섬유, 케이블 : 물리적인 연결을 담당 (비트 단위)

전송 단위 : 메시지 -> 세그먼트/데이터그램 -> 패킷 -> 프레임 -> 전기신호
데이터 전송 시 단위 : 내려가면서 헤더정보가 붙고(= 캡슐화) 올라가면서 헤더정보가 제거됨(= 역캡슐화), 표현만 패킷일 뿐 정확히 전송 단위는 위에 설명한 것처럼 됨.

2. 소캣 프로그래밍
소캣은 IP주소 + 포트번호로 구성된 통신을 위한 양 끝단의 인터페이스 (API와 같은 것)
즉, 서버와 클라이언트가 전송계층(TCP/UDP)를 통해 데이터를 주고받기 위한 창구.
보내는 데이터의 단위는 TCP/UDP 어떤 소캣인지에 따라 다르다. 

TCP소캣의 경우 데이터 단위는 스트림(연속된 바이트의 흐름) : 데이터를 한 번에 보내지 않고 끊어서 보내기도 함.
UDP소캣의 경우 데이터 단위는 메시지/데이터그램(경계가 있는 고정된 단위) : 데이터를 한번에 보낸다.

3. 통신 과정

서버는 아래와 같은 단계를 거침
1) DNS로부터 접점(IP주소 + 포트번호)를 구함
2) 리스너 소캣을 생성하고 접점의 정보를 Bind함
3) 리스너 소캣을 통해 최대 접속자 수를 조정하고 받음
4) 메시지를 클라이언트로부터 받고 응답
* 리스너 소캣은 클라이언트의 연결을 수락하기 위한 소캣
* 클라이언트와 연결이 되면 서버에 새로운 소캣을 생성(세션도 같이 생성해서 클라이언트 상태를 추적한다)
* 세션은 클라이언트와 서버간의 연결 상태를 추적하고 유지하기 위한 논리적 연결 정보.

클라이언트는 아래와 같은 단계를 거침
1) 서버와 마찬가지로 접점의 정보를 구함
2) 소캣을 생성하고 접점의 정보를 통해 연결을 시도
3) 연결이되면 서버와 메시지를 주고 받는다

4. 세션
어떤 클라이언트인지(접점 정보), 연결 시간, 인증 상태, 로그인 정보 등 저장(즉, 클라이언트의 관한 내용을 기록해둠)

세션 구성
연결된 클라이언트에 대한 소캣 정보가 필요
SetBuffer를 통해 받는 데이터를 저장할 공간을 확보 & 어디서부터 읽을지 설정

Receive
비동기로 호출하는 방식으로 구현 가능하다.

Disconnect
Flag를 사용하여 중복 호출을 방지하면 문제가 생기지 않는다.

Send
언제 호출하여 보낼 지 알 수 없기 때문에 Receive와 같은 일반적인 콜백으로 사용할 수 없다.
매번 전송하는 버퍼에 대한 정보를 미리 알 수 없기 때문에 다시 등록해서 사용할 수 없다. (asynceventargs 재사용 불가능)
* Send와 Receive하는 부분에서 가장 많은 부하가 일어난다. 
100명의 유저가 움직인다면 100*100의 정보를 보내고 받아야하기 때문이다. 
그렇기 때문에 Register로 Send를 할 수도 없고 하면 문제가 생김.
* 뭉치고 재사용할 수 있는 방법으로 구현해야 함.

Send 개선
- SendArgs를 전역변수로 생성해서 등록. (재사용을 위해)
- 큐를 이용하여 버퍼를 쌓아뒀다가 한번에 전송

 
